from __future__ import annotations

import argparse
import re
import subprocess
import sys
import textwrap
from collections import ChainMap
from logging import Logger

from rich.console import Console

from cve_bin_tool.error_handler import ErrorHandler, ErrorMode
from cve_bin_tool.extractor import Extractor, TempDirExtractorContext
from cve_bin_tool.log import LOGGER
from cve_bin_tool.strings import parse_strings
from cve_bin_tool.util import DirWalk
from cve_bin_tool.version_scanner import VersionScanner


class GenericChecker:
    """helps to find the product,version if not known from the binary or packages"""

    CONSOLE = Console()
    LOGGER: Logger = LOGGER.getChild("GenericChecker")

    def __init__(
        self,
        product_name: str | None = None,
        version_number: str | None = None,
        string_length: int = 40,
    ):
        self.extractor: TempDirExtractorContext = Extractor()
        self.product_name = product_name
        self.version_number = version_number
        self.product_list = []
        self.version_list = []
        # for extraction
        self.walker = DirWalk().walk

        # for scanning files versions
        self.version_scanner = VersionScanner()

    def extract_and_parse_file(self, filename: str) -> list[str] | None:
        # if the file is ELF binary file, don't try to parse its filename or extract it
        if self.version_scanner.is_executable(filename)[0]:
            return self.parse_execfile(filename)
        else:
            # extract the file and search for the regex in the file
            with self.extractor as ectx:
                binary_string_list: list[str] = []
                if ectx.can_extract(filename):
                    for filepath in self.walker([ectx.extract(filename)]):
                        clean_path = self.version_scanner.clean_file_path(filepath)
                        LOGGER.debug(f"checking whether {clean_path} is binary")

                        # see if the file is ELF binary file and parse for strings
                        is_exec = self.version_scanner.is_executable(filepath)[0]
                        if is_exec:
                            execfile_path = self.parse_execfile(filepath)
                            if execfile_path is not None:
                                binary_string_list += execfile_path

                LOGGER.info(binary_string_list)
                return binary_string_list

    def parse_execfile(self, filename: str) -> list[str] | None:
        # Parses executable file for finding generic regex

        LOGGER.debug(f"{filename} <--- this is an ELF binary")
        file_content = parse_strings(filename)

        if self.product_name is None or self.version_number is None:
            return self.gen_checker(file_content)

        return None

    def gen_checker(
        self,
        file_content: str,
    ) -> list[str]:
        """Find the regex in the file and return the different Product and their version found in the file using the regex"""

        file_content_list = file_content.split("\n")

        if self.product_name is not None:
            self.product_list.append(self.product_name)
            if self.version_number is None:
                self.version_number = ""
            self.version_number.append(self.version_number)

        rege = r"([a-zA-Z]+)([\s|-]|\r\n)(\d+\.\d+\.\d+)"
        matches = []
        for i, line in enumerate(file_content_list):
            produ = re.search(rege, line, re.IGNORECASE)
            if produ:
                if line.find(".debug") != -1:
                    continue
                matches.append(line.strip())
                continue

        final_matches = [*set(matches)]
        for i in final_matches:
            if len(i.split(" ")) >= 2:
                products_name = i.split(" ")[0]
                versions_number = i.split(" ")[1]
                if products_name not in self.product_list:
                    self.product_list.append(products_name)
                    self.version_list.append(versions_number)
                if versions_number not in self.version_list:
                    self.product_list.append(products_name)
                    self.version_list.append(versions_number)
            else:
                rege = r"(?P<product>[a-zA-Z]+)([\s|-]|\r\n)(?P<version>\d+\.\d+\.\d+)"
                match = re.search(rege, i)
                if match:
                    groups = match.groupdict()
                    products_name = groups.get("product")
                    versions_number = groups.get("version")
                    if products_name not in self.product_list:
                        self.product_list.append(products_name)
                        self.version_list.append(versions_number)
                    if versions_number not in self.version_list:
                        self.product_list.append(products_name)
                        self.version_list.append(versions_number)
                else:
                    LOGGER.critical("No match found.")
                continue
        LOGGER.debug(
            f"found matches  = {matches}"
        )  # TODO: regex highlight in these matched strings?
        LOGGER.debug(f"final matches found ={final_matches} ")
        return final_matches

    def operator_function(self, filename: str) -> None:
        # Get the filename and call the other function
        LOGGER.info(f"filename receive in the operator_function = {filename}")
        matches = self.extract_and_parse_file(filename)
        LOGGER.info(f"matches found by the program = {matches}")
        self.search_for_new_generic(matches, filename)

    def search_for_new_generic(self, matches: list[str], filename: str) -> None:
        # Run helper script on the file with the product name and the version extracted from the file
        LOGGER.info(f"this is the product {self.product_list}")
        LOGGER.info(f"this is the version {self.version_list}")
        for product, version in zip(self.product_list, self.version_list):
            subprocess.run(
                [
                    "python",
                    "-m",
                    "cve_bin_tool.helper_script",
                    filename,
                    "--product",
                    product,
                    "--version",
                    version,
                ]
            )


def main(argv=None) -> None:

    argv = argv or sys.argv

    parser = argparse.ArgumentParser(
        prog="helper-script",
        description=textwrap.dedent(
            """
                Generic checker is a program which is recommend to use when you dont have the information about
                the product and its version.
            """
        ),
    )
    # scan directory args
    parser.add_argument(
        "filenames",
        help="files to scan",
        nargs="+",
        default=[],
    )
    # log level args
    parser.add_argument(
        "-l",
        "--log",
        help="log level (default: warning)",
        dest="log_level",
        action="store",
        choices=["debug", "info", "warning", "error", "critical"],
        default="warning",
    )

    with ErrorHandler(mode=ErrorMode.NoTrace):
        raw_args = parser.parse_args(argv[1:])
        args = {key: value for key, value in vars(raw_args).items() if value}
        defaults = {key: parser.get_default(key) for key in vars(raw_args)}

    args = ChainMap(args, defaults)

    LOGGER.setLevel(args["log_level"].upper())
    hs = GenericChecker()
    filename = args["filenames"][0]
    hs.operator_function(filename)


if __name__ == "__main__":
    main()
